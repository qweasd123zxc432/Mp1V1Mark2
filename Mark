Алгоритм Беллмана-Форда «находит кратчайшие пути от одной вершины до всех остальных и может работать с графами, содержащими отрицательные веса»
граф классов:
 def __init__(self, вершины):
 self.V = vertices # Количество вершин
 self.edges = [] # Список рёбер

 определение add_edge(self, u, v, w):
 self.edges.append((u, v, w))

 def bellman_ford(self, src):
 # Инициализация расстояний
 расстояние = [число с плавающей точкой («бесконечность»)] * скорость
 расстояние[src] = 0

 # Основной цикл
 для _ в диапазоне (self.V - 1):
 для u, v, w в self.edges:
 если distance[u] != float("inf") и distance[u] + w < расстояние[v]:
 расстояние [v] = distance[u] + w

 # Проверка на наличие отрицательных циклов
 для u, v, w в self.edges:
 если distance[u] != float("inf") и distance[u] + w < расстояние[v]:
 print("Граф содержит отрицательный цикл")
 вернуть None

 расстояние возврата


Алгоритм Дейкстры находит кратчайший путь от одной вершины до всех остальных и работает только с неотрицательными весами.
импортировать heapq

класс GraphDijkstra:
 def __init__(self, вершины):
 self.V = vertices # Количество вершин
 self.рёбра = {i: [] для i в диапазоне (вершин)} # Словарь рёбер

 определение add_edge(self, u, v, w):
 self.edges[u].добавить((v, w))
 self.edges[v].append((u, w)) # Если граф неориентированный

 деф дейкстра(self, src):
 расстояние = [число с плавающей точкой («бесконечность»)] * скорость
 расстояние[src] = 0
 priority_queue = [(0, src)]

 в то время как priority_queue:
 dist_u, u = heapq.heappop(очередь с приоритетом)

 для v, вес в self.edges[u]:
 если расстояние [u] + вес < расстояние [v]:
 расстояние [v] = расстояние [u] + вес
 heapq.heappush(очередь_с_приоритетом, (расстояние[v], v))

 расстояние возврата
Для тестирования нужно создать граф с более чем 100 вершинами и использовать два алгоритма.

импортировать случайным образом
время импорта

определение generate_graph(num_vertices, num_edges):
 график = Graph(num_vertices)
 graph_dijkstra = GraphDijkstra(num_vertices)

 для _ в диапазоне (num_edges):
 u = random.randint(0, num_vertices - 1)
 v = random.randint(0, num_vertices - 1)
 w = random.randint(1, 10) # Положительные веса для Дейкстры
 график.add_edge(u, v, w)
 graph_dijkstra.add_edge(u, v, w)

 возвращает график, graph_dijkstra

количество обращений = 150
num_edges = 500
граф, граф_Дейкстры = generate_graph(количество_вершин, количество_рёбер)

# Тестирование алгоритма Беллмана-Форда
start_time = time.time()
bf_distances = график.bellman_ford(0)
print(f"Алгоритм Беллмана-Форда завершён за {time.time() - start_time:.5f} секунд.")

# Тестирование алгоритма Дейкстры
start_time = time.time()
расстояния_Дейкстры = граф_Дейкстры.Дейкстра(0)
